 <!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<title>AI:TaeNah</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<style>
  body { background:#181f2a; color:#fff; font-family:'Pretendard', Arial, sans-serif; margin:0; padding:0; }
  .container { max-width:560px; margin:auto; padding:1.5rem; }
  .tabs { display:flex; gap:12px; margin-bottom:1.2rem; }
  .tab { background:#232b3b; color:#9ad1f6; padding:.8rem 1.4rem; border-radius:1.5rem; border:none; cursor:pointer; font-size:1.06rem; font-weight:600; }
  .tab.active { background:linear-gradient(90deg,#228be6,#f5a623); color:#fff; }

  .current-section { display:flex; justify-content:space-between; align-items:center; margin-bottom:1.6rem; }
  .current-price { font-size:2.1rem; font-weight:bold; color:#ffe089; letter-spacing:-1px; }
  .ai-score-wrap { display:flex; flex-direction:column; align-items:flex-end; }
  .ai-score-label { font-size:1.1rem; color:#a1a5bb; }
  .ai-score-bar { width:190px; height:22px; background:#303a52; border-radius:16px; overflow:hidden; }
  .ai-score-bar-inner { height:100%; border-radius:16px; background:linear-gradient(90deg,#2196f3 60%,#ff9100 100%); transition:width .5s; }
  .ai-score-num { font-size:1.25rem; color:#53fc18; margin-top:.2rem; }

  .mini-chart-bg { background:#252e40; border-radius:9px; padding:.8rem .5rem; margin-bottom:1.5rem; }
  #miniSpark, #backtestBar { width:100% !important; display:block; }

  .strategy-section, .backtest-section, .indicator-section { margin-bottom:1.7rem; }
  .strategy-title { font-size:1.15rem; color:#ffe089; margin-bottom:.3rem; }
  .strategy-main { font-size:1.02rem; color:#f7c683; font-weight:600; margin-bottom:.2rem; }
  .strategy-desc { font-size:.99rem; color:#bfcbe6; }

  .backtest-bg { background:#22263a; border-radius:8px; padding:1.1rem .7rem; }
  .backtest-title { font-size:1.05rem; color:#7d8fb7; margin-bottom:.3rem; }
  .bt-sub { color:#9fb0d6; font-size:.92rem; margin-top:.35rem; }

  .indicators-table { width:100%; border-collapse:collapse; background:#232b3b; border-radius:12px; overflow:hidden; }
  .indicators-table th, .indicators-table td { padding:.5rem; text-align:left; }
  .indicators-table th { background:#22263a; color:#d6e5f7; }
  .indicators-table tr { border-bottom:1px solid #22263a; }
  .ind-score-bar { width:85px; height:9px; background:#303a52; border-radius:7px; margin-top:4px; }
  .ind-score-inner { height:100%; background:linear-gradient(90deg,#f5a623 0%,#3eb489 100%); border-radius:7px; }

  @media (max-width:600px) {
    .container { padding:.7rem; }
    .ai-score-bar { width:100px; }
  }
  @media (max-width:400px) {
    .tab { font-size:.95rem; padding:.6rem 1rem; }
    .ai-score-bar { width:90px; height:18px; }
    .ai-score-num { font-size:1.1rem; }
    .current-price { font-size:1.8rem; }
    .strategy-main, .strategy-desc { font-size:.95rem; }
    .indicators-table th, .indicators-table td { font-size:.88rem; padding:.4rem; }
  }

  .exit-table-wrap { margin-top:1.1rem; background:#20283c; border-radius:7px; padding:.7rem .6rem; }
  .exit-table { width:100%; border-collapse:collapse; }
  .exit-table th, .exit-table td { font-size:.93rem; padding:.34rem .5rem; }
  .exit-table th { color:#ffe089; }
  .exit-table tr { border-bottom:1px solid #2c3244; }
  .exit-table td { color:#d6e5f7; }
  .exit-table .td-w { color:#53fc18; }
  .exit-table .td-l { color:#f5a623; }

  .hl7_5 td { background:#1f2b3f !important; }
  .hl7_5 td:first-child { box-shadow: inset 4px 0 0 #00e5ff; }
  .hl7_5 td:nth-child(4) { color:#00e5ff !important; font-weight:700; }
</style>
</head>
<body>
<script>
/** ▼▼▼ 여기에 본인 Cloudflare Worker/Vercel/Netlify 프록시 주소 넣기 ▼▼▼ */
const PROXY_BASE = "https://YOUR-WORKER-NAME.workers.dev";  // 예: https://ai-upbit-proxy.workers.dev
function upbit(path){ return `${PROXY_BASE}/upbit?path=${encodeURIComponent(path)}`; }
/** ▲▲▲ 반드시 교체하세요! ▲▲▲ */

document.addEventListener("DOMContentLoaded", function () {
  if (typeof Android !== "undefined" && Android !== null) {
    try { if (window.Android.requestNotificationPermission) Android.requestNotificationPermission(); } catch (e) {}
  }
});

/* 공통 안전 fetch */
async function safeJsonFetch(url){
  try{
    const r = await fetch(url, { headers: { 'accept':'application/json' }});
    if(!r.ok) throw new Error(r.status + ' ' + r.statusText);
    return await r.json();
  }catch(e){
    console.warn('API 요청 실패:', url, e);
    return null;
  }
}
</script>

<div class="container">
  <div class="tabs">
    <button class="tab active" onclick="selectCoin('BTC')">BTC</button>
    <button class="tab" onclick="selectCoin('ETH')">ETH</button>
    <button class="tab" onclick="selectCoin('SOL')">SOL</button>
    <button class="tab" onclick="selectCoin('XRP')">XRP</button>
  </div>

  <div class="current-section">
    <div>
      <div class="current-price" id="currentPrice">–</div>
      <div id="coinTitle" style="color:#7de7fd;font-size:1rem;">– 240분봉</div>
    </div>
    <div class="ai-score-wrap">
      <div class="ai-score-label">AI 종합 점수</div>
      <div class="ai-score-bar">
        <div class="ai-score-bar-inner" id="aiScoreBar" style="width:0%"></div>
      </div>
      <div class="ai-score-num" id="aiScoreNum">– / 10</div>
    </div>
  </div>

  <div class="mini-chart-bg">
    <canvas id="miniSpark"></canvas>
  </div>

  <div class="strategy-section">
    <div class="strategy-title">AI 전략 제안</div>
    <div class="strategy-main" id="strategyMain">–</div>
    <div class="strategy-desc" id="strategyDesc">–</div>
    <div class="strategy-desc" style="color:#62fcfe;">※ 투자 참고용, 실제 투자 전 반드시 검증 필요</div>
  </div>

  <div class="backtest-section">
    <div class="backtest-title">백테스트 결과 및 전략 수익률</div>
    <div class="backtest-bg">
      <div id="backtestResult" style="font-size:1.02rem; margin-bottom:.3rem;">–</div>
      <canvas id="backtestBar"></canvas>
      <div class="bt-sub" id="btExtras"></div>
      <div id="exitTableWrap"></div>
    </div>
  </div>

  <div class="indicator-section">
    <table class="indicators-table" id="indicatorTable"></table>
  </div>
</div>

<script>
let notifiedScore = 0;
const TAKE_PROFIT_SCORE = 7.5;
const BUY_TIME_SUFFIX   = "05:00:00";

const coinMeta = {
  BTC: { market:"KRW-BTC", name:"비트코인" },
  ETH: { market:"KRW-ETH", name:"이더리움" },
  SOL: { market:"KRW-SOL", name:"솔라나" },
  XRP: { market:"KRW-XRP", name:"리플" }
};

const indNames = [
  "RSI(14)","MACD(12,26,9)","ADX(14)","CCI(20)","Stoch(14,3)","DMI(+DI–DI)",
  "OBV","MFI(14)","Bollinger","SMA괴리율","EMA괴리율","ATR(14)","Williams %R",
  "ROC(10)","TRIX(15)","UltimateOsc","CMO","StochRSI","Price Osc","VPT","PVT","Force Index"
];
let indAcc = Array(22).fill(80);

let lastMini=null;
let lastBarPayload=null;

function calcRSI(c,p=14){let rsi=[],g=[],l=[];for(let i=1;i<c.length;i++){let d=c[i]-c[i-1];g.push(d>0?d:0);l.push(d<0?-d:0);}let ag=g.slice(0,p).reduce((a,b)=>a+b)/p,al=l.slice(0,p).reduce((a,b)=>a+b)/p;rsi[p]=al===0?100:100-(100/(1+ag/al));for(let i=p+1;i<c.length;i++){ag=(ag*(p-1)+g[i-1])/p;al=(al*(p-1)+l[i-1])/p;rsi[i]=al===0?100:100-(100/(1+ag/al));}return rsi;}
function calcMACD(c,f=12,s=26,si=9){function ema(a,p){let k=2/(p+1),e=[a.slice(0,p).reduce((x,y)=>x+y)/p];for(let i=1;i<a.length;i++)e[i]=k*(a[i]-e[i-1])+e[i-1];return e;}let fe=ema(c,f),se=ema(c,s),m=[],sg=[],h=[];for(let i=0;i<c.length;i++)m[i]=(fe[i]||0)-(se[i]||0);sg=ema(m,si);for(let i=0;i<c.length;i++)h[i]=(m[i]||0)-(sg[i]||0);return{macd:m,signal:sg,hist:h};}
function calcADX(h,l,c,p=14){let pd=[],md=[],tr=[];for(let i=1;i<h.length;i++){let up=h[i]-h[i-1],dn=l[i-1]-l[i];pd.push(up>dn&&up>0?up:0);md.push(dn>up&&dn>0?dn:0);tr.push(Math.max(h[i]-l[i],Math.abs(h[i]-c[i-1]),Math.abs(l[i]-c[i-1])));}function sma(a,pp,i){return a.slice(i-pp+1,i+1).reduce((x,y)=>x+y)/pp;}let pdi=[],mdi=[],dx=[],adx=[];for(let i=p-1;i<pd.length;i++){let sum=sma(tr,p,i),sp=sma(pd,p,i),sm=sma(md,p,i);pdi[i]=100*(sp/sum);mdi[i]=100*(sm/sum);dx[i]=100*Math.abs(pdi[i]-mdi[i])/(pdi[i]+mdi[i]);}for(let i=2*p-2;i<dx.length;i++)adx[i]=dx.slice(i-p+1,i+1).reduce((x,y)=>x+y)/p;return adx;}
function calcCCI(h,l,c,p=20){let cci=[];for(let i=p-1;i<c.length;i++){let tp=[],sum=0;for(let j=i-p+1;j<=i;j++){let v=(h[j]+l[j]+c[j])/3;tp.push(v);sum+=v;}let ma=sum/p,md=tp.reduce((x,y)=>x+Math.abs(y-ma),0)/p;cci[i]=md===0?0:(tp[tp.length-1]-ma)/(0.015*md);}return cci;}
function calcStochastic(h,l,c,kp=14,dp=3){let kArr=[],dArr=[];for(let i=kp-1;i<c.length;i++){let hi=Math.max(...h.slice(i-kp+1,i+1)),lo=Math.min(...l.slice(i-kp+1,i+1));kArr[i]=((c[i]-lo)/(hi-lo))*100;}for(let i=kp-1+dp-1;i<kArr.length;i++)dArr[i]=kArr.slice(i-dp+1,i+1).reduce((x,y)=>x+y)/dp;return{k:kArr,d:dArr};}
function calcDMI(h,l,c,p=14){let pd=[],md=[],tr=[];for(let i=1;i<h.length;i++){let up=h[i]-h[i-1],dn=l[i-1]-l[i];pd.push(up>dn&&up>0?up:0);md.push(dn>up&&dn>0?dn:0);tr.push(Math.max(h[i]-l[i],Math.abs(h[i]-c[i-1]),Math.abs(l[i]-c[i-1])));}function sma(a,pp,i){return a.slice(i-pp+1,i+1).reduce((x,y)=>x+y)/pp;}let pdi=[],mdi=[];for(let i=p-1;i<pd.length;i++){let sum=sma(tr,p,i),sp=sma(pd,p,i),sm=sma(md,p,i);pdi[i]=100*(sp/sum);mdi[i]=100*(sm/sum);}return{plus:pdi,minus:mdi};}
function calcOBV(c,v){let obv=[v[0]];for(let i=1;i<c.length;i++){obv[i]=c[i]>c[i-1]?obv[i-1]+v[i]:c[i]<c[i-1]?obv[i-1]-v[i]:obv[i-1];}return obv;}
function calcMFI(h,l,c,v,p=14){let mfi=[];for(let i=p-1;i<c.length;i++){let pos=0,neg=0;for(let j=i-p+1;j<=i;j++){let tp=(h[j]+l[j]+c[j])/3;tp>c[j-1]?pos+=tp*v[j]:tp<c[j-1]?neg+=tp*v[j]:0;}let r=neg===0?0:pos/neg;mfi[i]=100-(100/(1+r));}return mfi;}
function calcBollinger(c,p=20,m=2){let up=[],lo=[],bs=[];for(let i=p-1;i<c.length;i++){let sl=c.slice(i-p+1,i+1),ma=sl.reduce((x,y)=>x+y)/p,std=Math.sqrt(sl.reduce((x,y)=>x+Math.pow(y-ma,2),0)/p);bs[i]=ma;up[i]=ma+m*std;lo[i]=ma-m*std;}return{upper:up,lower:lo,basis:bs};}
function calcSMA(a,p){let sm=[];for(let i=p-1;i<a.length;i++)sm[i]=a.slice(i-p+1,i+1).reduce((x,y)=>x+y)/p;return sm;}
function calcEMA(a,p){let e=[];let k=2/(p+1);e[p-1]=a.slice(0,p).reduce((x,y)=>x+y)/p;for(let i=p;i<a.length;i++)e[i]=a[i]*k+e[i-1]*(1-k);return e;}
function calcATR(h,l,c,p=14){let tr=[];for(let i=1;i<h.length;i++)tr.push(Math.max(h[i]-l[i],Math.abs(h[i]-c[i-1]),Math.abs(l[i]-c[i-1])));let at=[];for(let i=p-1;i<tr.length;i++)at[i]=tr.slice(i-p+1,i+1).reduce((x,y)=>x+y)/p;return at;}
function calcWilliamsR(h,l,c,p=14){let wr=[];for(let i=p-1;i<c.length;i++){let hi=Math.max(...h.slice(i-p+1,i+1)),lo=Math.min(...l.slice(i-p+1,i+1));wr[i]=((hi-c[i])/(hi-lo))*-100;}return wr;}
function calcROC(c,p=10){let roc=[];for(let i=p;i<c.length;i++)roc[i]=(c[i]-c[i-p])/c[i-p]*100;return roc;}
function calcTRIX(c,p=15){let ema1=calcEMA(c,p),ema2=calcEMA(ema1.slice(p-1),p),ema3=calcEMA(ema2.slice(p-1),p),trix=[];for(let i=1;i<ema3.length;i++)trix[i+p*3-3]=(ema3[i]-ema3[i-1])/ema3[i-1]*100;return trix;}
function calcUltimateOsc(h,l,c,s1=7,s2=14,s3=28){let ult=[];for(let i=Math.max(s1,s2,s3)-1;i<c.length;i++){let bp=[],tr=[];for(let j=i-Math.max(s1,s2,s3)+1;j<=i;j++){bp.push(c[j]-Math.min(l[j],c[j-1]));tr.push(Math.max(h[j],c[j-1])-Math.min(l[j],c[j-1]));}let sum=(n)=>bp.slice(-n).reduce((a,b)=>a+b)/tr.slice(-n).reduce((a,b)=>a+b);ult[i]=100*(4*sum(s1)+2*sum(s2)+sum(s3))/7;}return ult;}
function calcCMO(c,p=14){let up=[],dn=[],cmo=[];for(let i=1;i<c.length;i++){let d=c[i]-c[i-1];up.push(d>0?d:0);dn.push(d<0?-d:0);}for(let i=p-1;i<up.length;i++){let u=up.slice(i-p+1,i+1).reduce((a,b)=>a+b),d=dn.slice(i-p+1,i+1).reduce((a,b)=>a+b);cmo[i+1]=((u-d)/(u+d))*100;}return cmo;}
function calcStochRSI(c,p=14){let rsi=calcRSI(c,p),stochrsi=[];for(let i=p;i<rsi.length;i++){let min=Math.min(...rsi.slice(i-p+1,i+1)),max=Math.max(...rsi.slice(i-p+1,i+1));stochrsi[i]=max-min===0?0:(rsi[i]-min)/(max-min);}return stochrsi;}
function calcPriceOsc(c,p=14){let ema=calcEMA(c,p),osc=[];for(let i=p-1;i<c.length;i++)osc[i]=c[i]-ema[i];return osc;}
function calcVPT(c,v){let vpt=[0];for(let i=1;i<c.length;i++)vpt[i]=vpt[i-1]+v[i]*((c[i]-c[i-1])/c[i-1]);return vpt;}
function calcPVT(c,v){let pvt=[0];for(let i=1;i<c.length;i++)pvt[i]=pvt[i-1]+v[i]*((c[i]-c[i-1])/c[i-1]);return pvt;}
function calcForceIndex(c,v,p=13){let fi=[];for(let i=1;i<c.length;i++)fi[i]=c[i]-c[i-1]*v[i];let ema=calcEMA(fi.slice(1),p);return ema;}

function getAutoScaleRange(arr, minBand=0.05, maxBand=0.95){
  const f=arr.filter(v=>v!=null&&!isNaN(v)); if(!f.length) return [0,1];
  f.sort((a,b)=>a-b); const mi=Math.floor(f.length*minBand), ma=Math.ceil(f.length*maxBand)-1;
  return [f[mi], f[ma]];
}
function scale(v, min, max, toMin=0, toMax=10){
  if(v==null||isNaN(v)) return 0; v=Math.max(min,Math.min(max,v));
  return ((v-min)/(max-min))*(toMax-toMin)+toMin;
}

function fitCanvasToParent(canvas, cssHeightPx){
  const dpr = window.devicePixelRatio || 1;
  canvas.style.width  = '100%';
  canvas.style.height = cssHeightPx + 'px';
  const cssW = Math.max(1, canvas.clientWidth);
  const cssH = cssHeightPx;
  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, cssW, cssH };
}

let currentCoin = "BTC";
function selectCoin(coin){
  currentCoin = coin;
  document.querySelectorAll('.tab').forEach((b,i)=>b.classList.toggle('active', ["BTC","ETH","SOL","XRP"][i]===coin));
  loadData();
}

async function loadData(){
  const { market, name } = coinMeta[currentCoin];
  document.getElementById('coinTitle').innerText = `${name} 240분봉`;

  // 현재가 (프록시 경유)
  const ticker = await safeJsonFetch(upbit(`/v1/ticker?markets=${market}`));
  if (ticker && ticker[0]) {
    document.getElementById('currentPrice').innerText = '₩' + ticker[0].trade_price.toLocaleString();
  }

  // 캔들 (프록시 경유)
  const candlesJson = await safeJsonFetch(upbit(`/v1/candles/minutes/240?market=${market}&count=200`));
  if (!candlesJson) return; // 실패 시 종료
  const candles = candlesJson.reverse();

  const closes = candles.map(d=>d.trade_price),
        highs  = candles.map(d=>d.high_price),
        lows   = candles.map(d=>d.low_price),
        vols   = candles.map(d=>d.candle_acc_trade_volume),
        n      = closes.length-1;

  /* ===== 계산/스코어/전략 (이하 동일) ===== */
  const rsi=calcRSI(closes), macd=calcMACD(closes), adx=calcADX(highs,lows,closes),
        cci=calcCCI(highs,lows,closes), stoch=calcStochastic(highs,lows,closes), dmi=calcDMI(highs,lows,closes),
        obv=calcOBV(closes,vols), mfi=calcMFI(highs,lows,closes,vols), boll=calcBollinger(closes),
        sma=calcSMA(closes,20), ema=calcEMA(closes,20), atr=calcATR(highs,lows,closes),
        wr=calcWilliamsR(highs,lows,closes), roc=calcROC(closes), trix=calcTRIX(closes),
        ult=calcUltimateOsc(highs,lows,closes), cmo=calcCMO(closes), stochrsi=calcStochRSI(closes),
        priceOsc=calcPriceOsc(closes), vpt=calcVPT(closes,vols), pvt=calcPVT(closes,vols), force=calcForceIndex(closes,vols);

  const arrs=[rsi,macd.macd,adx,cci,stoch.k,dmi.plus,obv,mfi,boll.upper,sma,ema,atr,wr,roc,trix,ult,cmo,stochrsi,priceOsc,vpt,pvt,force];
  const mins=arrs.map(a=>getAutoScaleRange(a)[0]);
  const maxs=arrs.map(a=>getAutoScaleRange(a)[1]);

  let sumAcc=0, newAcc=[];
  for(let i=0;i<22;i++){
    let win=0, tot=0, a=arrs[i];
    for(let j=21;j<n;j++){
      if(scale(a[j],mins[i],maxs[i])>=TAKE_PROFIT_SCORE){ if((closes[j+1]-closes[j])>0) win++; tot++; }
    }
    newAcc[i]=tot?Math.round(win/tot*100):indAcc[i]; sumAcc+=newAcc[i];
  }
  indAcc=newAcc; const indWeightsInit=indAcc.map(acc=>acc/sumAcc);

  const indScores=arrs.map((a,i)=>scale(a[n],mins[i],maxs[i]));
  const aiScore=Math.round(indScores.reduce((s,v,i)=>s+v*indWeightsInit[i],0)*10)/10;
  const aiScoreFinal=Math.max(0,Math.min(10,aiScore));

  if (window.Android && typeof window.Android.showNotification==='function'){
    if(aiScoreFinal>=8.0 && notifiedScore!==aiScoreFinal){
      window.Android.showNotification(`${name} 알림`,`AI 종합 점수 ${aiScoreFinal.toFixed(1)} / 10\n익절 신호 발생!`);
      notifiedScore=aiScoreFinal;
    }
  }
  document.getElementById('currentPrice').innerText='₩'+closes[n].toLocaleString();
  document.getElementById('aiScoreBar').style.width=(aiScoreFinal*10)+'%';
  document.getElementById('aiScoreNum').innerText=aiScoreFinal.toFixed(1)+' / 10';

  // 미니 스파크라인(최근 24개)
  let mini=[]; for(let j=n-23;j<=n;j++){ let s=0; for(let k=0;k<22;k++) s+=scale(arrs[k][j],mins[k],maxs[k])*indWeightsInit[k]; mini.push(Math.round(s*10)/10); }
  lastMini = mini.slice();
  drawSparkline('miniSpark', mini, 6.5);

  // 전략 코멘트
  let main, desc;
  if (aiScoreFinal >= 7.5) { main='강력한 익절 신호: 전량 매도'; desc=`AI 점수 ${aiScoreFinal.toFixed(1)} 이상에서 전량 매도 권장`; }
  else if (aiScoreFinal >= 7.0) { main='부분 매도: 50% 매도'; desc=`AI 점수 ${aiScoreFinal.toFixed(1)}에서 보유 물량의 절반 매도 권장`; }
  else if (aiScoreFinal >= 6.5) { main='부분 매도: 25% 매도'; desc=`AI 점수 ${aiScoreFinal.toFixed(1)}에서 보유 물량의 25% 매도 권장`; }
  else { main='보유 지속, 1일 1회 DCA 매수'; desc='특별한 매도 신호가 없을 때는 매일 1회 DCA(정액 매수)로 리스크 분산'; }
  document.getElementById('strategyMain').innerText=main;
  document.getElementById('strategyDesc').innerText=desc;

  // 백테스트
  let cash=0, coin=0, yields=[], exitLog=[];
  const BUY_AMT=10000; let state='buying', entryPrice=0, wins=0, losses=0, buyAmount=0;
  const scoreArr=closes.map((_,i)=>{ let s=0; for(let k=0;k<22;k++) s+=scale(arrs[k][i],mins[k],maxs[k])*indWeightsInit[k]; return Math.round(s*10)/10; });

  for(let i=0;i<closes.length;i++){
    if(scoreArr[i]>=TAKE_PROFIT_SCORE && coin>0){
      cash+=coin*closes[i];
      const avgEntry=buyAmount/(coin||1), ret=(closes[i]-avgEntry)/avgEntry;
      exitLog.push({idx:i, datetime:candles[i].candle_date_time_kst.replace("T"," "), price:closes[i], score:scoreArr[i], pnl:ret, type:(ret>0?'win':'loss')});
      ret>0?wins++:losses++; coin=0; buyAmount=0; entryPrice=0; state='buying';
    }
    if(state==='buying' && candles[i].candle_date_time_kst.includes(BUY_TIME_SUFFIX)){
      coin += BUY_AMT / closes[i]; cash -= BUY_AMT; if(coin>0 && entryPrice===0) entryPrice=closes[i];
      buyAmount += BUY_AMT; state='holding';
    }
    yields.push(cash + coin*closes[i]);
  }
  cash += coin*closes[n];

  const buyCount=yields.filter((_,i)=>candles[i].candle_date_time_kst.includes(BUY_TIME_SUFFIX)).length;
  const invested=Math.max(1,buyCount*BUY_AMT);
  const eqCurvePerc=yields.map(v=>(v/invested)*100);

  // MDD
  let peak=-Infinity, mdd=0, mddIndex=-1;
  if(eqCurvePerc.length>0){
    eqCurvePerc.forEach((v,i)=>{
      if(peak===-Infinity) peak=v;
      if(v>peak) peak=v;
      const dd = peak!==0 ? ((v/peak)-1)*100 : 0;
      if(isFinite(dd) && dd<mdd){ mdd=dd; mddIndex=i; }
    });
  }

  // 7등분 막대 + MDD 막대 인덱스 매핑
  const step = Math.floor(eqCurvePerc.length/7) || 1;
  let retPerc=[]; for(let i=0;i<eqCurvePerc.length;i+=step){ retPerc.push(Math.round(eqCurvePerc[i]*10)/10); }
  const deltas=retPerc.map((v,i)=> i===0?0:Math.round((v-retPerc[i-1])*10)/10);
  let mddBarIndex = (mddIndex>=0) ? Math.min(retPerc.length-1, Math.max(0, Math.round(mddIndex/step))) : -1;

  // 변동폭(표준편차)
  const changes=deltas.slice(1);
  const meanDelta=changes.length?(changes.reduce((a,b)=>a+b,0)/changes.length):0;
  const varDelta =changes.length?(changes.reduce((a,b)=>a+Math.pow(b-meanDelta,2),0)/changes.length):0;
  const volDelta =Math.sqrt(varDelta);

  lastBarPayload = { vals: retPerc.slice(), deltas: deltas.slice(), mddBarIndex, mdd };
  drawBacktestBar('backtestBar', retPerc, deltas, mddBarIndex, mdd);

  // 날짜별 최고 점수만 남기기
  const exitByDate={};
  exitLog.forEach(e=>{
    const d=e.datetime.substring(0,10);
    if(e.score>=TAKE_PROFIT_SCORE){ if(!exitByDate[d] || e.score>exitByDate[d].score) exitByDate[d]=e; }
  });
  const exitFiltered=Object.values(exitByDate).sort((a,b)=>a.datetime.localeCompare(b.datetime));
  const filteredWins=exitFiltered.filter(e=>e.type==='win').length;
  const filteredLoss=exitFiltered.filter(e=>e.type==='loss').length;

  document.getElementById('backtestResult').innerHTML =
    `200봉 전략수익률 <span style="color:#53fc18;">${Number(retPerc.slice(-1)[0]??0).toFixed(1)}%</span><br>`+
    `익절 ${exitFiltered.length}회 (수익:${filteredWins}/손실:${filteredLoss})<br>`+
    `매수(일일) ${buyCount}회`;

  document.getElementById('btExtras').innerHTML =
    `최대낙폭(MDD): <span style="color:#f5a623;">${isFinite(mdd)?mdd.toFixed(1):'0.0'}%</span>  ·  `+
    `구간 변동폭(표준편차): ${isFinite(volDelta)?volDelta.toFixed(2):'0.00'}%p  ·  `+
    `최고 구간: ${(changes.length?((Math.max(...changes)>=0?'+':'')+Math.max(...changes).toFixed(1)):'0.0')}%  ·  `+
    `최저 구간: ${(changes.length?((Math.min(...changes)>=0?'+':'')+Math.min(...changes).toFixed(1)):'0.0')}%`;

  const todayKST=new Date().toLocaleString('sv-SE',{timeZone:'Asia/Seoul'}).slice(0,10);
  let exitTableHtml='';
  if(exitFiltered.length>0){
    exitTableHtml='<div class="exit-table-wrap"><div style="font-size:.99rem;color:#ffe089;margin-bottom:2px;">익절(매도) 발생 내역</div>';
    exitTableHtml+='<table class="exit-table"><thead><tr><th>#</th><th>시점</th><th>가격</th><th>AI점수</th><th>수익률</th></tr></thead><tbody>';
    exitFiltered.forEach((e,idx)=>{
      const rowDate=e.datetime.substring(0,10);
      const trClass=(rowDate===todayKST && e.score>=TAKE_PROFIT_SCORE)?' class="hl7_5"':'';
      exitTableHtml+=`<tr${trClass}>
        <td>${idx+1}</td>
        <td>${e.datetime.substr(0,16)}</td>
        <td>${e.price.toLocaleString()}</td>
        <td>${e.score.toFixed(1)}</td>
        <td class="${e.type==='win'?'td-w':'td-l'}">${(e.pnl*100).toFixed(1)}%</td>
      </tr>`;
    });
    exitTableHtml+='</tbody></table></div>';
  }else{
    exitTableHtml='<div class="exit-table-wrap"><div style="font-size:.99rem;color:#ffe089;">익절(매도) 내역 없음</div></div>';
  }
  document.getElementById('exitTableWrap').innerHTML=exitTableHtml;

  // 지표 테이블
  let th=`<thead><tr><th>지표</th><th>점수</th><th>가중치</th><th>정확도</th></tr></thead>`, tb='';
  for(let i=0;i<22;i++){
    tb+=`<tr><td>${indNames[i]}</td>
      <td>${indScores[i]?.toFixed(2) ?? "-"}<div class="ind-score-bar"><div class="ind-score-inner" style="width:${(indScores[i]*10).toFixed(1)}%"></div></div></td>
      <td>${(indWeightsInit[i]??0).toFixed(3)}</td><td>${indAcc[i]??"-"}%</td></tr>`;
  }
  document.getElementById('indicatorTable').innerHTML=th+'<tbody>'+tb+'</tbody>';
}

/* ===== 차트 ===== */
function drawSparkline(id, data, threshold = 6.5){
  const c = document.getElementById(id); if (!c) return;
  const r = fitCanvasToParent(c, 36); if (!r) return;
  const { ctx, cssW:w, cssH:h } = r;

  ctx.clearRect(0,0,w,h);
  const p=7, n=data.length;
  const min=Math.min(...data,0), max=Math.max(...data,10);
  const sx=(w-2*p)/(n-1), sy=(h-2*p)/(max-min||1);

  const yThr = h - p - ((threshold - min) * sy);
  ctx.save(); ctx.setLineDash([4,3]); ctx.strokeStyle="#00e5ff"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(p,yThr); ctx.lineTo(w-p,yThr); ctx.stroke(); ctx.restore();

  ctx.beginPath(); ctx.moveTo(p, h-p-(data[0]-min)*sy);
  for(let i=1;i<n;i++) ctx.lineTo(p+sx*i, h-p-(data[i]-min)*sy);
  ctx.strokeStyle="#53fc18"; ctx.lineWidth=2; ctx.stroke();

  ctx.beginPath(); ctx.arc(p+sx*(n-1), h-p-(data[n-1]-min)*sy, 4, 0, Math.PI*2);
  ctx.fillStyle="#ffe089"; ctx.fill();

  for(let i=0;i<n;i++){
    if(data[i] >= threshold){
      const x=p+sx*i, y=h-p-(data[i]-min)*sy;
      ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2);
      ctx.fillStyle="#00e5ff"; ctx.fill();
      ctx.lineWidth=1.2; ctx.strokeStyle="#0b1d2e"; ctx.stroke();
    }
  }
}

function drawBacktestBar(id, vals, deltas, mddBarIndex, mddValue){
  const c=document.getElementById(id); if(!c) return;
  const r = fitCanvasToParent(c, 40); if(!r) return;
  const { ctx, cssW:w, cssH:h } = r;

  ctx.clearRect(0,0,w,h);
  const p=9, n=vals.length;
  const min=Math.min(...vals), max=Math.max(...vals);
  const gap=(w-2*p)/n;
  const bw=gap*0.8;

  for(let i=0;i<n;i++){
    const x=p+i*gap;
    const y=h-p-((vals[i]-min)/(max-min+0.01))*(h-2*p-8);
    const up = i===0 ? true : (deltas[i] >= 0);
    ctx.globalAlpha=i==n-1?1:0.9;
    ctx.fillStyle = up ? "#53fc18" : "#f5a623";
    ctx.fillRect(x,y,bw,h-p-y);
    if(i==n-1){
      ctx.globalAlpha=1; ctx.fillStyle="#ffe089"; ctx.font="bold 12px Pretendard";
      ctx.fillText((vals[i]>0?"+":"")+Number(vals[i]).toFixed(1)+"%", x+4, y-4);
    }
  }

  // MDD 지점 표시
  if (typeof mddBarIndex === 'number' && mddBarIndex >= 0 && mddBarIndex < n && isFinite(mddValue)) {
    const x = p + mddBarIndex*gap + bw/2;
    const y = h - p - ((vals[mddBarIndex]-min)/(max-min+0.01))*(h-2*p-8);

    ctx.save();
    ctx.setLineDash([3,3]);
    ctx.strokeStyle="#ff7171";
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, h-p); ctx.stroke();
    ctx.restore();

    ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2);
    ctx.fillStyle="#ff4444"; ctx.fill();

    ctx.font="bold 11px Pretendard";
    ctx.fillStyle="#ffcccb";
    ctx.fillText(mddValue.toFixed(1) + "%", x+6, y-6);
  }
}

/* ===== 로드/주기/리사이즈 ===== */
window.onload=function(){ selectCoin("BTC"); };
setInterval(()=>{ loadData(); },30000);
window.addEventListener('resize', ()=>{
  if (lastMini) drawSparkline('miniSpark', lastMini, 6.5);
  if (lastBarPayload) drawBacktestBar('backtestBar', lastBarPayload.vals, lastBarPayload.deltas, lastBarPayload.mddBarIndex, lastBarPayload.mdd);
});
window.selectCoin=selectCoin;
</script>

<!-- 디스클레이머 -->
<div style="margin:2.3rem 0 1.1rem 0; text-align:center;">
  <div class="disclaimer" style="color:#b6b8be;font-size:.97rem; margin-bottom:.18rem;">
    ⓒ 2025 TaeNah.<br>
    본 시뮬레이터는 참고용이며, 투자 손실에 대한 책임을 지지 않습니다.<br>
    업비트 API 데이터 참고용이며, 업비트 운영사와 무관합니다.
  </div>
</div>
</body>
</html>
